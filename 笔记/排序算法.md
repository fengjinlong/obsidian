## 冒泡排序 O(n^2)
1. 比较相邻的两个数，第一个比第二个大，交换位置。
```js

for (let i = 0; i<length; i++){
	for (let j=0; j<length-1; j++){
		// 比较，交换
	}
}
```
2. 改进，不重复比较。
```js

// 第二层循环
for (let j = 0; j<length-1-i; j++){}
```
## 选择排序
1. 找到最小的放到第一位，找到第二小的放第二位
```js

function selectSort(arr) {
  const length = arr.length;
  let minIndex;
  for (let i = 0; i < length; i++) {
    minIndex = i;
    for (let j = i; j < length; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    if (i !== minIndex) {
      swap(arr, i, minIndex);
    }
  }
  return arr;
}
```
```js


```
## 插入排序
1. 每次排一个数组项。
2. 假定第一个已经排序了。
3. 第一项与第二项对比，确定12
4. 第三项与第一项第二项对比，确定123
```js

function insertSort(arr) {
  let temp;
  for (let i = 1; i < arr.length; i++) {
    let j = i;
    temp = arr[i];
    while (j > 0 && arr[j - 1] > temp) {
      arr[j] = arr[j - 1];
      j--;
    }
    arr[j] = temp;
  }
  return arr;
}
```
## 归并排序（可以实际使用的排序）
1. 分而治之的算法
	1. 将原始数组分为较小的数组，直到只有一项
	2. 接着把小数组归并为一个大数组
	3. 分治法，递归
2. 算法分为两个函数
	1. 第一个函数负责将大数组分为小数组，并调用排序函数
	2. 排序函数
```js

function mergeSort(arr) {
  if (arr.length > 1) {
    const { length } = arr;
    let middle = Math.floor(length / 2);
    const left = mergeSort(arr.slice(0, middle));
    const right = mergeSort(arr.slice(middle, length));
    arr = merge(left, right);
  }
  return arr;
}

function merge(left, right) {
  let i = 0;
  let j = 0;
  const result = [];
  while (i < left.length && j < right.length) {
    let small = left[i] < right[j] ? left[i++] : right[j++];
    result.push(small);
  }
  // left right 谁还没空
  return result.concat(i < left.length ? left.slice(i) : right.slice(j));
}
```