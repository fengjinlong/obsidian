{
	"nodes":[
		{"type":"text","text":"### renderRoot\n1. 初始化第一次的workInProgress， prepareFreshStack(root)。这里有个重点，即使是页面的挂载，有同时存在的 currentFiber 和 wipFiber 的节点，那就是 hostRootFiber\n2. workLoop()\n3. commitRoot(root)","id":"2a206214fc1f8a90","x":88,"y":70,"width":612,"height":270,"color":"1"},
		{"type":"text","text":"#### workLoop()\n1. 递归  performUnitOfWork(workInProgress)\n```js\nwhile (workInProgress !== null) {\n  performUnitOfWork(workInProgress);\n}\n```\n2. workInProgress 是全局的\n","id":"f871373abd620208","x":134,"y":480,"width":521,"height":300},
		{"type":"text","text":"![](Pasted%20image%2020230426001644.png)\n\n[react-workLoop 递归顺序.excalidraw](react-workLoop%20递归顺序.excalidraw.md)","id":"c40d18c6e2f6fbe0","x":-780,"y":340,"width":480,"height":576},
		{"type":"text","text":"1. 创建一个更新 update，{ action }\n2. 将更新插入到 hostRootFiber 的 更新队列 ，updateQueue.shared.pending = update\n3. 调度hostRootFiber， scheduleUpdateOnFiber(hostRootFiber)","id":"3694c578c1b8743a","x":20,"y":-687,"width":760,"height":175},
		{"type":"text","text":"performUnitOfWork(wip)\n1. next = beginWork(wip) 返回 子节点 next，即使在mount阶段 第一次 wip 是hostRootFiber 的，是存在的！！！。然后变为 子fiber 的wip ，子 fiber 的 wip 是不存在的！！！\n2. 如果 有next ，workInProgress = next，递归上面逻辑\n3. 没有next， 就执行 completeUnitOfWork( wip )","id":"e0a6cbf06cec1a4c","x":27,"y":1095,"width":735,"height":380},
		{"type":"text","text":"#### commitRoot 不可中断\n1. 处理副作用标记 commitMutationEffects(finishedWork);\n2. 移动指针 root.current = finishedWork","id":"d8cfab36c755264d","x":27,"y":1800,"width":735,"height":200,"color":"4"},
		{"type":"text","text":"main.tsx","id":"9f65ead52e69f295","x":-1503,"y":-629,"width":250,"height":60},
		{"type":"text","text":"createContainer(container)\n1. hostRootFiber = new FiberNode(HostRoot, {}, null);\n2. root = new FiberRootNode(container, hostRootFiber);  此时 root 与 hostRootFiber 已经关联了\n3. hostRootFiber.updateQueue = createUpdateQueue();","id":"da727eb191a71364","x":-1360,"y":-1089,"width":580,"height":200},
		{"type":"text","text":"ReactDOM.createRoot(root).render(<App />);\n1. createRoot 创建 root\n\t1. createContainer(container);\n2. render(<App /> \n\t1. 初始化 initEvent\n\t2. updateContainer(element, root)","id":"5870380d4418ba9d","x":-1120,"y":-739,"width":644,"height":280},
		{"type":"text","text":"initEvent(container, 'click');","id":"8287cf37e4bf14b7","x":-476,"y":-989,"width":300,"height":60},
		{"type":"text","text":"#### 更新阶段要处理的流程\n1. beginWork\n2. completeWork\n3. commitWork\n4. useState\n\n[react-更新流程](react-更新流程.md)","id":"465412042e605c96","x":-780,"y":1137,"width":508,"height":280,"color":"6"},
		{"type":"text","text":"#### beginWork(wip) ，wip.tag 分类型处理\n1. HostRoot, hostRoot 可以触发更新，所以有计算状态的逻辑\n\t1. 计算状态最新值，wip.memoizedState = memoizedState ，这里 memoizedState 也就是 reactElement 即 App\n\t2. reconcileChildren(wip, nextChildren) 根据 子currentFiber 和 子 reactElement 计算出 子 wip fiber\n\t3. return next = wip.child\n2. HostComponent 不能触发更新\n\t1. reconcileChildren(wip, nextChildren)\n\t2. return next = wip.child\n3. HostText 不能触发更新\n\t1. return next = null\n4. FunctionComponent 不能触发更新\n\t1. reconcileChildren(wip, nextChildren);","id":"99e6f850030df323","x":1960,"y":520,"width":800,"height":520},
		{"type":"text","text":"##### 为了 wip.child = xxxx\n1. 挂载阶段 根据reactElement 生成 子 wip，并返回\n2. 更新节点判断是否可复用 子 wip，并标记 flags。即使是 mount 阶段，所有子wip 都没有挂载 flag，但是hostRootFiber 的 wip 是执行更新阶段，也就是说只有它有 挂载 flag。一次性挂载。\n3. 单节点\n4. 多节点 \n\n#### 更新阶段的 beginWork\n1. 在创建 wip 时候\n2. 复用 能复用的 fiber，不能复用就创建\n3. 标记要删除的 flags\n4. 标记移动 的 flags","id":"dc916e1b86cafcba","x":1960,"y":1277,"width":800,"height":475},
		{"type":"text","text":"#### completeWork\n1. HostComponent，HostText需要关联 dom tree,  wip.stateNode = instance as element\n2. 将 flags 冒泡到父级 fiber, 最终到 hostRootFiber\n\n\n#### 更新阶段 completeWork\n1. 给text 添加更新的 flag\n2. 变更属性","id":"a3ec753fa7a2b1d1","x":1960,"y":2040,"width":800,"height":320},
		{"type":"text","text":"### useEffect\n1. beginWork 的 mount 阶段\n\t1. 创建 hook\n\t2. 添加一个需要执行副作用的 effect\n2. beginWork 的 update 阶段\n\t1. 创建 hook，复用之前的数据，判断前后数量是否一样\n\t2. deps 浅比较，hook.memoizedState = effect1\n\t\t1. [] 或者 相同，添加一个不需要执行副作用的 effect1\n\t\t2. 不同，添加一个需要执行副作用的 effect1\n3. completeWork 冒泡副作用标记\n4. commitRoot \n\t1. 如果有副作用，调度器用  异步异步异步异步异步 调度并**按顺序**执行相应的 副作用 \n\t2. 顺序是 -- 卸载的 destroy----更新的 destroy----更新的 creata\n\t3. 执行之前的 commitMutationEffects，添加一个收集的逻辑\n\t\t1. 之前是  插入节点，修改属性，删除子节点\n\t\t2. 添加，收集回调。{ unmount: [], update: [] }\n","id":"424367458c690186","x":3080,"y":-54,"width":1240,"height":571},
		{"type":"text","text":"#### commitMutationEffects(finishedWork)\n1. 递归查找 finishedWork 是否有 flages标记，递归顺序跟 workLoop 递归顺序 一致，找到有 flags 进行处理 即 commitMutaitonEffectsOnFiber","id":"3edd1eba12e2fd27","x":27,"y":2740,"width":735,"height":200},
		{"type":"text","text":"### useState\n##### mount 阶段\n1. 数据共享层拿到 mount 阶段的 useState\n2. 返回 [ initState, dispatch ]\n3. dispatch 函数内部的逻辑 \n\t1. 创建一个更新，并插入 hook 的更新队列\n\t2. 当前调度的函数 fiber.memoizedState = hook\n\t3. 调度当前的 函数fiber，即 scheduleUpdateOnFiber(fiber)\n4. 当用户执行 dispach 时候就是 再次调度，也就是 useState 更新阶段\n#### update 阶段\n1. beginWork 从新计算属性值\n2. commit 阶段更新","id":"acca51732ad653c8","x":1960,"y":-858,"width":1137,"height":518},
		{"type":"text","text":"#### commitMutaitonEffectsOnFiber(finishedWork)\n1. 添加节点\n\n\n#### 更新阶段的 commitRoot\n-   对于`ChildDeletion`，需要遍历被删除的子树\n-   对于`Update`的 flags，需要更新文本内容\n\n#### 到这里 页面呈现元素","id":"29a5f79e1da4337d","x":1960,"y":2640,"width":972,"height":400,"color":"1"},
		{"type":"text","text":"prepareFreshStack(root)\n1. 这个 wip 是 root.current 对应的，也就是 hostRootFiber 的 wip。根只有一个，根没有 wip\n2. 也就是找 wip = current.alternate, 有就是更新阶段，没有就是 mount 阶段\n3. wip 挂载 flags, update, state，child 等","id":"a69b755920c794fb","x":1969,"y":70,"width":560,"height":250},
		{"type":"text","text":"scheduleUpdateOnFiber","id":"3e6cbf011b1a325c","x":762,"y":-88,"width":302,"height":68},
		{"type":"text","text":"更新，万物的根源\n1. 更新的队列 createUpdateQueue \n```js\n{\n  shared: {\n    pending: null\n  },\n  dispatch: null\n}\n```\n","id":"a690b2d19bfcbf04","x":-1326,"y":-1489,"width":513,"height":320},
		{"type":"text","text":"### 数据共享池","id":"638af84ce6e6c61e","x":3530,"y":-639,"width":340,"height":80,"color":"4"}
	],
	"edges":[
		{"id":"152cc34826061911","fromNode":"8287cf37e4bf14b7","fromSide":"left","toNode":"5870380d4418ba9d","toSide":"top"},
		{"id":"61a9f24ae95d27c2","fromNode":"5870380d4418ba9d","fromSide":"right","toNode":"3694c578c1b8743a","toSide":"left","label":"updateContainer"},
		{"id":"bfbea4325fdd6576","fromNode":"9f65ead52e69f295","fromSide":"right","toNode":"5870380d4418ba9d","toSide":"left"},
		{"id":"16d0f5185c47b70f","fromNode":"da727eb191a71364","fromSide":"bottom","toNode":"5870380d4418ba9d","toSide":"top"},
		{"id":"b8822ffc194ff90c","fromNode":"a690b2d19bfcbf04","fromSide":"bottom","toNode":"da727eb191a71364","toSide":"top"},
		{"id":"185b982d9e1fa6a5","fromNode":"3694c578c1b8743a","fromSide":"bottom","toNode":"2a206214fc1f8a90","toSide":"top","label":"scheduleUpdateOnFiber\n1. 递归找到根 root\n\n2. renderRoot(root)"},
		{"id":"9096d712c75d3c5d","fromNode":"2a206214fc1f8a90","fromSide":"right","toNode":"a69b755920c794fb","toSide":"left","label":"prepareFreshStack"},
		{"id":"fa8f6182e7f31bcc","fromNode":"2a206214fc1f8a90","fromSide":"bottom","toNode":"f871373abd620208","toSide":"top","label":"workLoop()"},
		{"id":"91bc1c3580a9973f","fromNode":"f871373abd620208","fromSide":"bottom","toNode":"e0a6cbf06cec1a4c","toSide":"top","label":"performUnitOfWork( wip )"},
		{"id":"72cc11807980652a","fromNode":"e0a6cbf06cec1a4c","fromSide":"right","toNode":"99e6f850030df323","toSide":"left","label":"beginWork(wip)"},
		{"id":"8f0a7c5d13231e64","fromNode":"99e6f850030df323","fromSide":"bottom","toNode":"dc916e1b86cafcba","toSide":"top","label":"reconcileChildren(wip, nextChildren)"},
		{"id":"16008f139df3ea34","fromNode":"e0a6cbf06cec1a4c","fromSide":"right","toNode":"a3ec753fa7a2b1d1","toSide":"left","label":"completeUnitOfWork(wip)"},
		{"id":"7ef6ed2b5c93291a","fromNode":"f871373abd620208","fromSide":"left","toNode":"c40d18c6e2f6fbe0","toSide":"right","label":"workLoop 递归顺序"},
		{"id":"2bfb09149a467e69","fromNode":"e0a6cbf06cec1a4c","fromSide":"bottom","toNode":"d8cfab36c755264d","toSide":"top","label":"commitRoot"},
		{"id":"a02d9c54a7895ea0","fromNode":"d8cfab36c755264d","fromSide":"bottom","toNode":"3edd1eba12e2fd27","toSide":"top","label":"commitMutationEffects(finishedWork)"},
		{"id":"7c5791a84bcd667a","fromNode":"3edd1eba12e2fd27","fromSide":"right","toNode":"29a5f79e1da4337d","toSide":"left"},
		{"id":"030460fa3cb1017f","fromNode":"3e6cbf011b1a325c","fromSide":"left","toNode":"2a206214fc1f8a90","toSide":"top"},
		{"id":"b6e208416df60443","fromNode":"acca51732ad653c8","fromSide":"bottom","toNode":"3e6cbf011b1a325c","toSide":"right"},
		{"id":"da454da3d7241979","fromNode":"638af84ce6e6c61e","fromSide":"left","toNode":"acca51732ad653c8","toSide":"right","color":"4"},
		{"id":"a7b001104f7277f8","fromNode":"638af84ce6e6c61e","fromSide":"bottom","toNode":"424367458c690186","toSide":"top","color":"4"},
		{"id":"0958bdda683826a2","fromNode":"424367458c690186","fromSide":"bottom","toNode":"99e6f850030df323","toSide":"right"},
		{"id":"f8070914f290cd30","fromNode":"424367458c690186","fromSide":"bottom","toNode":"a3ec753fa7a2b1d1","toSide":"right"},
		{"id":"dd6a53d00da2788f","fromNode":"424367458c690186","fromSide":"bottom","toNode":"29a5f79e1da4337d","toSide":"right"}
	]
}