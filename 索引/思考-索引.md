## 双端diff
#### 1 双端比较的原理
存在下图新旧子节点
![](image%201.png)

如果使用简单 diff，需要移动两次 dom，如下图
![](Pasted%20image%2020220317235506.png)

如果只是把旧节点的 p-3 对应的dom 移动到 旧节点的 p-1 前面，只需要移动一次 dom。双端 diff 可以做到这种操作。如下图
![](Pasted%20image%2020220318000927.png)

顾名思义，双端diff, 是一种同时对新旧两组节点的两个端点进行比较的算法，所以需要四个索引值。如下图 
![](Pasted%20image%2020220318002035.png)

代码表示
```javascript
function patchChildren(n1, n2, container) {
  if (typeof n2.children === "string") {
    // ... 元素
  } else if (Array.isArray(n2.children)) {
    patchKeyedChildren(n1, n2, container);
  } else {
    // ...
  }
}
function patchKeyedChildren(n1, n2, container) {
  const oldChildren = n1.children;
  const newChildren = n2.children;

  // 四个索引
  let oldStartIdx = 0;
  let oldEndIdx = oldChildren.length - 1;
  let newStartIdx = 0;
  let newEndIdx = newChildren.length - 1;
  // 四个索引指向的虚拟节点
  let oldStartVNode = oldChildren[oldStartIdx];
  let oldEndVNode = oldChildren[oldEndIdx];
  let newStartVNode = newChildren[newStartIdx];
  let newEndVNode = newChildren[newEndIdx];
}

```

双端比较中，分为四个步骤，如下图连线所示
![](Pasted%20image%2020220318003915.png)

第一步：旧的头节点p-1 与新的头节点p-4 比较，key不同，不可复用，什么都不做。
第二步：旧的尾结点p-4 与新的尾节点p-3 比较，key不同，不可复用，什么都不做。
第三步：旧的头节点p-1 与新的尾节点p-3 比较，key不同，不可复用，什么都不做。
第四步：旧的尾节点p-4 与新的头节点p-4 比较，key相同，dom可复用。

可以看出，旧的尾节点p-4 更新之后应该是第一个节点。在逻辑里应该这样解释：`将索引为 oldEndIdx 指向的虚拟节点所对应的dom 移动到索引为 oldStartIdx 指向的虚拟节点所对应的dom 的前面`

上代码
```js
function patchKeyedChildren(n1, n2, container) {
  const oldChildren = n1.children;
  const newChildren = n2.children;

  // 四个索引
  let oldStartIdx = 0;
  let oldEndIdx = oldChildren.length - 1;
  let newStartIdx = 0;
  let newEndIdx = newChildren.length - 1;
  // 四个索引指向的虚拟节点
  let oldStartVNode = oldChildren[oldStartIdx];
  let oldEndVNode = oldChildren[oldEndIdx];
  let newStartVNode = newChildren[newStartIdx];
  let newEndVNode = newChildren[newEndIdx];

  if (oldStartVNode.key === newStartVNode.key) {
    // 第一步
  } else if (oldEndVNode.key === newEndVNode.key) {
    // 第二步
  } else if (oldStartVNode.key === newEndVNode.key) {
    // 第三步
  } else if (oldEndVNode.key === newStartVNode.key) {
    // 第四步
    /**
     * 1 patch 节点打补丁
     * 2 移动
     * 3 更新索引值
     */
    // 1
    patch(oldEndVNode, newStartVNode, container);
    // 2
    insert(oldEndVNode.el, container, oldStartVNode.el);
    // 3
    oldEndIdx--;
    newStartIdx++;
    oldEndVNode = oldChildren[oldEndIdx];
    newStartVNode = newChildren[newStartIdx];
  }
}
```

此步骤后，新旧节点如下图
![](Pasted%20image%2020220318011338.png)
