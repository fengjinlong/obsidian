1. 栈内存中的基本类型，可以通过操作系统直接处理；而堆内存中的引用类型，正是由于可以经常变化，大小不固定，因此需要 JavaScript 的引擎通过垃圾回收机制来处理。
2. Chrome 的内存回收机制。Chrome 的 JavaScript 引擎 V8 将**堆内存**分为两类 新生代的回收机制和老生代的回收机制

## 新生代
4. ![](Pasted%20image%2020220517080136.png)
左边部分表示正在使用的内存空间，右边是目前闲置的内存空间。当浏览器开始进行内存的垃圾回收时，JavaScript 的 V8 引擎会将左边的对象检查一遍。如果引擎检测是存活对象，那么会复制到右边的内存空间去；如果不是存活的对象，则直接进行系统回收。当所有左边的内存里的对象没有了的时候，等再有新生代的对象产生时，上面的部分左右对调，这样来循环处理
4. 顺序放置的那比较好处理，可以按照上面所说的处理方式。但是如果是下图这样零散的场景怎么处理呢
![](Pasted%20image%2020220517080323.png)
算法 Scavenge，它主要就是解决上图中内存碎片的情

## 老生代内存回收
新生代中的变量如果经过回收之后依然一直存在，那么就会被放入到老生代内存中
老生代内存中的垃圾回收采用了 Mark-Sweep（标记清除） 和 Mark-Compact（标记整理）的策略
#### 标记清除
遍历堆上的所有的对象，打上标记；然后在代码执行过程结束之后，对使用过的变量取消标记。那么没取消标记的就是没有使用过的变量，因此在清除阶段，就会把还有标记的进行整体清除，从而释放内存空间。
#### 标记整理
在标记清除的基础上演进而来的，和标记清除来对比来看，标记整理添加了活动对象整理阶段，处理过程中会将所有的活动对象往一端靠拢，整体移动完成后，直接清理掉边界外的内存

## 老生代内存的管理方式和新生代的内存管理方式区别还是比较大的。Scavenge 算法比较适合内存较小的情况处理；而对于老生代内存较大、变量较多的时候，还是需要采用“标记-清除”结合“标记-整理”这样的方式处理内存问题，并尽量避免内存碎片的产生
## 内存泄漏与优化
- 过多的缓存未释放；
- 闭包太多未释放；
- 定时器或者回调太多未释放；
- 太多无效的 DOM 未释放；
- 全局变量太多未被发现