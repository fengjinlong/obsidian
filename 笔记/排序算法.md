## 冒泡排序 O(n^2)
1. 比较相邻的两个数，第一个比第二个大，交换位置。
```js

for (let i = 0; i<length; i++){
	for (let j=0; j<length-1; j++){
		// 比较，交换
	}
}
```
2. 改进，不重复比较。
```js

// 第二层循环
for (let j = 0; j<length-1-i; j++){}
```
3. 改进
```js
function bubble2(arr) {
  console.time("bubble2");
  let low = 0;
  let high = arr.length - 1;
  let tmp, j;
  while (low < high) {
    for (j = low; j < high; j++) {
      if (arr[j] > arr[j + 1]) {
        tmp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = tmp;
      }
      high--;
    }
    for (j = high; j > low; j--) {
      if (arr[j] < arr[j - 1]) {
        tmp = arr[j];
        arr[j] = arr[j - 1];
        arr[j - 1] = tmp;
      }
      low++;
    }
  }
  console.timeEnd("bubble2");
  console.log("bubble2", arr);
}
```
## 选择排序
1. 找到最小的放到第一位，找到第二小的放第二位
```js

function selectSort(arr) {
  const length = arr.length;
  let minIndex;
  for (let i = 0; i < length; i++) {
    minIndex = i;
    for (let j = i; j < length; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    if (i !== minIndex) {
      swap(arr, i, minIndex);
    }
  }
  return arr;
}
```
```js


```
## 插入排序
[好文](https://juejin.cn/post/6844903936877395982)
1. 每次排一个数组项。
2. 假定第一个已经排序了。
3. 第一项与第二项对比，确定12
4. 第三项与第一项第二项对比，确定123
```js

function insertSort(arr) {
  let temp;
  for (let i = 1; i < arr.length; i++) {
    let j = i;
    temp = arr[i];
    while (j > 0 && arr[j - 1] > temp) {
      arr[j] = arr[j - 1];
      j--;
    }
    arr[j] = temp;
  }
  return arr;
}
```

## 希尔排序
1. 插入排序时间复杂度是 O(n^2)
2. 针对插入的优化方案
	1. 如果大部分都已经排序好了，那么插入的操作的次数就少
	2. 如果数组本身就少，那么插入的操作次数也少
	3. 希尔操作的 增量如果是 1，那么就是插入排序了
3. 希尔就是通过增量分组优化插入排序的
```js
// 6 3 1 当增量为 1 时候就是原来的插入排序了
function shell(arr) {
  for (let i = arr.length / 2; i > 0; i = Math.floor(i / 2)) {
    for (let j = i; j < arr.length; j++) {
      let temp = arr[j];
      let t = j - i;
      while (t >= 0 && arr[t] > temp) {
        arr[t + i] = arr[t];
        t -= i;
      }
      arr[t + i] = temp;
    }
  }
  return arr;
}
console.log("arr", shell([15, 2, 4, 3, 6, 8]));
```

## 归并排序（可以实际使用的排序）
1. 分而治之的算法
	1. 将原始数组分为较小的数组，直到只有一项
	2. 接着把小数组归并为一个大数组
	3. 分治法，递归
2. 算法分为两个函数
	1. 第一个函数负责将大数组分为小数组，并调用排序函数
	2. 排序函数
```js

function mergeSort(arr) {
  if (arr.length > 1) {
    const { length } = arr;
    let middle = Math.floor(length / 2);
    const left = mergeSort(arr.slice(0, middle));
    const right = mergeSort(arr.slice(middle, length));
    arr = merge(left, right);
  }
  return arr;
}

function merge(left, right) {
  let i = 0;
  let j = 0;
  const result = [];
  while (i < left.length && j < right.length) {
    let small = left[i] < right[j] ? left[i++] : right[j++];
    result.push(small);
  }
  // left right 谁还没空
  return result.concat(i < left.length ? left.slice(i) : right.slice(j));
}
```
## 快速排序 (最常用，O(nlogn))
1. 分治法，但是跟归并不同的是不用把数组分割开
2. 选择一个主元，数组中间的值。左右各两个指针
3. 移动左指针直到找到比主元大的，移动右指针知道找到比主元小的，交换这两个值。
4. 重复这个过程，直到左指针超过右指针。
5. 

```js

function quickSort(arr) {
  return quick(arr, 0, arr.length - 1);
}

function quick(arr, left, right) {
  let index;
  if (arr.length > 1) {
    index = partition(arr, left, right);
    if (left < index - 1) {
      quick(arr, left, index - 1);
    }
    if (index < right) {
      quick(arr, index, right);
    }
  }
  return arr;
}

function partition(arr, left, right) {
  const pivot = arr[Math.floor((left + right) / 2)];
  let i = left;
  let j = right;
  while (i <= j) {
    while (arr[i] < pivot) {
      i++;
    }
    while (arr[j] > pivot) {
      j--;
    }
    if (i <= j) {
      swap(arr, i, j);
      i++;
      j--;
    }
  }
  return i;
}
```