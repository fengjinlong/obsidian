## 双端diff - 非理想情况
#### 这次我们讨论非理想状态，先看下图
![](Pasted%20image%2020220318222010.png)

按照双端diff 进行更新
第一步：旧节点的头节点p-1 与新节点的头节点p-2 对比，key不同，不可复用。
第二步：旧节点的尾节点p-4 与新节点的尾节点p-3 对比，key不同，不可复用。
第三步：旧节点的头节点p-1 与新节点的尾节点p-3 对比，key不同，不可复用。
第四步：旧节点的尾节点p-4 与新节点的头节点p-2 对比，key不同，不可复用。

这时候怎么办？看看非头部，非尾部是否可以复用。
具体做法：那新的一组子节点中头部节点（newStartVNode）去旧的节点中寻找。代码如下
```js
  while (newStartIdx <= newEndIdx && oldStartIdx <= oldEndIdx) {
    if (oldStartVNode.key === newStartVNode.key) {
      // 第一步
    } else if (oldEndVNode.key === newEndVNode.key) {
      // 第二步
    } else if (oldStartVNode.key === newEndVNode.key) {
      // 第三步
    } else if (oldEndVNode.key === newStartVNode.key) {
      // 第四步
    } else {
      // 遍历旧节点，查找是否存在与 newStartVNode 可复用的节点
      const idxInOld = oldChildren.find(node => node.key === newStartVNode.key)
    }
  }
``` 
这样做的目的是什么呢？🌻 看下图
![](Pasted%20image%2020220318225033.png)

当我们拿新的一组节点的头节点p-2 去旧的一组节点中查找，会在索引为1 的位置找到可复用的节点。这就意味着 节点 p-2 应该变成头节点，🏋‍♀ 。实现如下
```js
while (newStartIdx <= newEndIdx && oldStartIdx <= oldEndIdx) {
    if (oldStartVNode.key === newStartVNode.key) {
      // 第一步
    } else if (oldEndVNode.key === newEndVNode.key) {
      // 第二步
    } else if (oldStartVNode.key === newEndVNode.key) {
      // 第三步
    } else if (oldEndVNode.key === newStartVNode.key) {
      // 第四步
    } else {
      // 遍历旧节点，查找是否存在与 newStartVNode 可复用的节点
      const idxInOld = oldChildren.find(
        (node) => node.key === newStartVNode.key
      );
      if (idxInOld > 0) {
        /**
         * 1 patch 打补丁
         * 2 移动
         * 3 置空
         * 4 跟新索引值,变换更新的索引指向的dom
         */
        const vnodeToMove = oldChildren[idxInOld];
        patch(vnodeToMove, newStartVNode, container);
        insert(vnodeToMove.el, container, oldStartVNode.el);
        oldChildren[idxInOld] = undefined;
        newStartIdx++;
        newStartVNode = newChildren[newStartIdx];
      }
    }
  }
```
此操作后，新旧节点，dom 如下图
![](Pasted%20image%2020220318232806.png)
双端diff 继续进行
第一步：旧节点的头节点p-1 与新节点的头节点p-4 对比，key不同，不可复用。
第二步：旧节点的尾节点p-4 与新节点的尾节点p-3 对比，key不同，不可复用。
第三步：旧节点的头节点p-1 与新节点的尾节点p-3 对比，key不同，不可复用。
第四步：旧节点的尾节点p-4 与新节点的头节点p-4 对比，key相同，dom可以复用。

按照之前的双端diff逻辑，进行移动。
此操作后，新旧节点，dom 如下图
![](Pasted%20image%2020220319155503.png)

接着，进行下一轮循环比较。
第一步：旧节点的头节点p-1 与新节点的头节点p-1 对比，key相同，dom可以复用。
按照之前的双端diff逻辑，只需进行打补丁，不需要移动。
此操作后，新旧节点，dom 如下图
![](Pasted%20image%2020220319161018.png)
接着，进行下一轮循环比较。
此时，旧的头节点是 undefined。说明该节点已经被处理，直接跳过即可。补充代码逻辑，如下
```js
  while (newStartIdx <= newEndIdx && oldStartIdx <= oldEndIdx) {
    if (!oldStartVNode) {
      /**
       * 1 索引变换
       * 2 索引对应的节点 改变
       */
      oldStartIdx++;
      oldStartVNode = oldChildren[oldStartIdx];
    } else if (!oldEndVNode) {
      oldEndIdx--;
      oldEndVNode = oldChildren[oldEndIdx];
    } else if (oldStartVNode.key === newStartVNode.key) {
      // 第一步
    } else if (oldEndVNode.key === newEndVNode.key) {
      // 第二步
    } else if (oldStartVNode.key === newEndVNode.key) {
      // 第三步
    } else if (oldEndVNode.key === newStartVNode.key) {
      // 第四步
    } else {
      // 遍历旧节点，查找是否存在与 newStartVNode 可复用的节点
      const idxInOld = oldChildren.find(
        (node) => node.key === newStartVNode.key
      );
      if (idxInOld > 0) {
        /**
         * 1 patch 打补丁
         * 2 移动
         * 3 置空
         * 4 跟新索引值,变换更新的索引指向的dom
         */
        const vnodeToMove = oldChildren[idxInOld];
        patch(vnodeToMove, newStartVNode, container);
        insert(vnodeToMove.el, container, oldStartVNode.el);
        oldChildren[idxInOld] = undefined;
        newStartIdx++;
        newStartVNode = newChildren[newStartIdx];
      }
    }
  }
```
此操作后，新旧节点，dom 如下图
![](Pasted%20image%2020220319163005.png)
接着，进行下一轮循环比较。
第一步：旧节点的头节点p-3 与新节点的头节点p-3 对比，key相同，dom可以复用。
按照之前的双端diff逻辑，只需进行打补丁，不需要移动。
此操作后，新旧节点，dom 如下图。
![](Pasted%20image%2020220319163902.png)

#### 添加新元素的情况


