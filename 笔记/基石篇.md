## 1. 引用类型
```js
let o = {
  a: 1,
};
function fun(obj) {
  obj.a = 2;
}
// o.a === 2
```

## 2. 数据类型判断

- typeof
  - 可以判断基础类型，null除外
  - 在引用类型中除了 function 外，其他不能判断
  - 返回的是 小写的类型
- instanceof
  - 可以判断复杂引用类型
  - 不可判断基础
```js
let car = new Car()
car instanceof Car // true

// 实现instanceof
function myInstanceof(left, right) {
  // 必须是引用类型
  if (typeof left !== "object" || left === null) {
    return false;
  }
  let proto = Object.getPrototypeOf(left);
  while (1) {
    if (proto === null) return false;
    if (proto === right.prototype) return true;
    proto = Object.getPrototypeOf(proto);
  }
}
```
- Object.prototype.toString.call()
  - 返回 [object Xxx] 第一个 X 要大写

## 3. 数据类型转换
##### Number() 方法的强制类型转换原则
1. 布尔值, 0 或 1
2. 数字, 本身
3. null, 0
4. undefined, NaN
5. 字符串
   1. 只包含数字，转换为十进制
   2. 只包含浮点数，浮点数
   3. 空字符串 0
   4. 其他，NaN
6. Symbol, 错误
7. 对象
   1. 如果对象部署了 [Symbol.toPrimitive] 那么调用此方法
   2. 否则，调用valueOf() 方法

```js
const a = {
  [Symbol.toPrimitive]() {
    return 200;
  },
  valueOf() {
    return 300;
  },
};
Number(a); // 200
```
#### 深浅拷贝
##### 浅拷贝 情况
1. object.assign
2. let o1 = {...o2}
3. concat 拷贝数组
4. let newArr = arr.slice(begin, end)

```js
// 手写浅拷贝
const shallowClone = (target) => {
  if (typeof target === "object" && target !== null) {
    const cloneTarget = Array.isArray(target) ? [] : {};
    for (let key in target) {
      if (target.hasOwnProperty(key)) {
        cloneTarget[key] = target[key];
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
};
```
##### 深拷贝
将一个对象从内存中完整的拷贝出来一份给目标对象，并从堆内存开辟一全新的空间存放新对象，且新对象的修改不影响原对象。
1. JSON.parse(JSON.stringify(obj))，存在以下问题
- 对象的值如果是函数，undefined,symbol,经过拷贝后，键值对 会消失
- Date 会变成 字符串
- 无法拷贝不可枚举类型
- 无法拷贝对象原型链
- RegExp 会变成 空对象
- 对象含有 NaN Infinity -Infinity 序列化后变成 null
- 无法拷贝对象的循环引用
