## 找函数的上一级作用域，这里的上一级指的是 函数定义时候的上一级

``` js
function test() {
  let a = 10;
  return function () {
    console.log(a);
  };
}
let a = 1;
let fn = test();
fn();

function test1(fn1) {
  let a1 = 123;
  fn1();
}
let a1 = 5;
function fn1() {
  console.log(a1);
}
test1(fn1);

```

#### 当函数可以   记住并访问   所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行 ——《你不知道的JavaScript》

![那么其实⼀切也就迎刃⽽解了。闭包的原理是Scope 堆空间中存储closure foo ，this的原理是动态绑定，作⽤域链的原理是Scope AO globalContext VO eval不能回收的原理是推不进AO 变量提升的原理是AO的准备阶段，异步队列的原理是ECS](执行栈AOVOEC闭包提升evel.md#那么其实⼀切也就迎刃⽽解了。闭包的原理是Scope%20堆空间中存储closure%20foo%20，this的原理是动态绑定，作⽤域链的原理是Scope%20AO%20globalContext%20VO%20eval不能回收的原理是推不进AO%20变量提升的原理是AO的准备阶段，异步队列的原理是ECS)
