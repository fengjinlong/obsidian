## 1. 引用类型
```js
let o = {
  a: 1,
};
function fun(obj) {
  obj.a = 2;
}
// o.a === 2
```

## 2. 数据类型判断

- typeof
  - 可以判断基础类型，null除外
  - 在引用类型中除了 function 外，其他不能判断
  - 返回的是 小写的类型
- instanceof
  - 可以判断复杂引用类型
  - 不可判断基础
```js
let car = new Car()
car instanceof Car // true

// 实现instanceof
function myInstanceof(left, right) {
  // 必须是引用类型
  if (typeof left !== "object" || left === null) {
    return false;
  }
  let proto = Object.getPrototypeOf(left);
  while (1) {
    if (proto === null) return false;
    if (proto === right.prototype) return true;
    proto = Object.getPrototypeOf(proto);
  }
}
```
- Object.prototype.toString.call()
  - 返回 [object Xxx] 第一个 X 要大写

## 3. 数据类型转换
##### Number() 方法的强制类型转换原则
1. 布尔值, 0 或 1
2. 数字, 本身
3. null, 0
4. undefined, NaN
5. 字符串
   1. 只包含数字，转换为十进制
   2. 只包含浮点数，浮点数
   3. 空字符串 0
   4. 其他，NaN
6. Symbol, 错误
7. 对象
   1. 如果对象部署了 [Symbol.toPrimitive] 那么调用此方法
   2. 否则，调用valueOf() 方法

```js
const a = {
  [Symbol.toPrimitive]() {
    return 200;
  },
  valueOf() {
    return 300;
  },
};
Number(a); // 200
```
#### 深浅拷贝
##### 浅拷贝 情况
1. object.assign
2. let o1 = {...o2}
3. concat 拷贝数组
4. let newArr = arr.slice(begin, end)

```js
// 手写浅拷贝
const shallowClone = (target) => {
  if (typeof target === "object" && target !== null) {
    const cloneTarget = Array.isArray(target) ? [] : {};
    for (let key in target) {
      if (target.hasOwnProperty(key)) {
        cloneTarget[key] = target[key];
      }
    }
    return cloneTarget;
  } else {
    return target;
  }
};
```
##### 深拷贝
将一个对象从内存中完整的拷贝出来一份给目标对象，并从堆内存开辟一全新的空间存放新对象，且新对象的修改不影响原对象。
1. JSON.parse(JSON.stringify(obj))，存在以下问题
- 对象的值如果是函数，undefined,symbol,经过拷贝后，键值对 会消失
- Date 会变成 字符串
- 无法拷贝不可枚举类型
- 无法拷贝对象原型链
- RegExp 会变成 空对象
- 对象含有 NaN Infinity -Infinity 序列化后变成 null
- 无法拷贝对象的循环引用
```js

// is obj ? function ?
const isComplexDataType = (obj) => {
  return (typeof obj === "object" || typeof obj === "function") && obj !== null;
};
const deepClone = function (obj, hash = new WeakMap()) {
  // 处理日期类型
  if (obj.constructor === Date) {
    return new Date(obj);
  }
  // 正则
  if (obj.constructor === RegExp) {
    return new RegExp(obj);
  }
  //如果循环引用了就用 weakMap 来解决
  if (hash.has(obj)) {
    return hash.get(obj);
  }
  //遍历传入参数所有键的特性
  let allDesc = Object.getOwnPropertyDescriptors(obj);
  //继承原型链
  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc);
  hash.set(obj, cloneObj);
  for (const key of Reflect.ownKeys(obj)) {
    /**
     * isComplexDataType(obj[key]) 是 obj 或 function
     * isComplexDataType(obj[key]) && typeof obj[key] !== "function"  是 obj
     * 如果是 obj 递归
     * 如果不是 obj 直接返回
     */
    cloneObj[key] =
      isComplexDataType(obj[key]) && typeof obj[key] !== "function"
        ? deepClone(obj[key], hash)
        : obj[key];
  }
  return cloneObj;
};

```

#### 继承
##### 原型链继承
```js
function Parent() {
  this.name = "parent";
  this.play = [1, 2];
}
function Child() {
  this.type = "child";
}
Child.prototype = new Parent();

let c = new Child();
```
问题
```js
  var s1 = new Child1();
  var s2 = new Child1();

  s1.play.push(4);
  console.log(s1.play, s2.play);
  // [1,2,4] [1,2,4]
```
两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。

##### 构造函数继承（call）
```js
function Parent1() {
  this.name = "parent1";
}
Parent1.prototype.getName = function () {
  return this.name;
};

function Child1() {
  Parent1.call(this);
  this.type = "child1";
}
let child = new Child1();
console.log(child); // 没问题
console.log(child.getName()); // 报错
```
构造函数实现继承的优缺点，它使父类的引用属性不会被共享，优化了第一种继承方式的弊端；但是随之而来的缺点也比较明显——只能继承父类的实例属性和方法，不能继承原型属性或者方法。

#### 组合继承（前两种组合）