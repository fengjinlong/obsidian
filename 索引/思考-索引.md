# 快速diff
#### vue.js 3 借鉴的快速diff 性能要稍优于 vue.js 2 的双端diff算法。
## 预处理步骤
#### 借鉴了纯文本的diff思路
##### 例如
1. 两端文本进行diff 之前，先进行全等比较
```js
if (text1 === text2) return // 快捷路径
```
2. 处理两段文本相同的前缀和后缀

T1: `I use` vue
T2: `I use` react

真正要diff 的部分是
```js
T1: vue
T2: react
```
##### 快速diff 借鉴了纯文本diff 的处理步骤。
1. 如下两组子节点
```js
旧节点：p-1 p-2 p-3
新节点：p-1 p-4 p-2 p-3
```
###### 对于相同的前置节点和后置节点，由于在新旧节点的相对位置不变，所以无需移动，只需要进行打补丁。
对于前置节点，建立索引 j ，其初始值为 0 ，用来指向两组节点的开头 如下图
![](Pasted%20image%2020220321223602.png)
开启一个 while 循环，让 j 递增，直到遇见不同节点为止，如下面 patchKeyedChildren 函数
```js
function patchKeyedChildren(n1, n2, container) {
  const newChildren = n2.children;
  const oldChildren = n1.children;
  // 处理相同的前置节点
  let j = 0;
  let oldVNode = oldChildren[j];
  let newVNode = newChildren[j];
  // 直到遇见不相同的节点为止
  while (oldVNode.key === newVNode.key) {
    // 打补丁
    patch(oldVNode, newVNode, container);
    j++;
    oldVNode = oldChildren[j];
    newVNode = newChildren[j];
  }
  // 完成前置节点的更新
}
```
此操作后，状态如下图
![](Pasted%20image%2020220321225322.png)
接下里处理相同的后置节点，由于新旧节点不一定长度相等，所以需要两个索引 newEnd 和 oldEnd，分别指向新旧节点的尾节点，如下图
![](Pasted%20image%2020220321230055.png)
再开启一个 while ，从后向前遍历两组节点，直到遇见key 不相同的节点为止，代码如下
```js
function patchKeyedChildren(n1, n2, container) {
  const newChildren = n2.children;
  const oldChildren = n1.children;
  // 处理相同的前置节点
  let j = 0;
  let oldVNode = oldChildren[j];
  let newVNode = newChildren[j];
  // 直到遇见不相同的节点为止
  // 完成前置节点的更新
  while (oldVNode.key === newVNode.key) {
    // 打补丁
    patch(oldVNode, newVNode, container);
    j++;
    oldVNode = oldChildren[j];
    newVNode = newChildren[j];
  }
  // 处理后置节点
  // 完成后置节点的更新
  let newEnd = newChildren.length - 1;
  let oldEnd = oldChildren.length - 1;
  oldVNode = oldChildren[oldEnd];
  newVNode = newChildren[newEnd];
  while (oldVNode.key === newVNode.key) {
    // 打补丁
    patch(oldVNode, newVNode, container);
    newEnd--;
    oldEnd--;
    oldVNode = oldChildren[oldEnd];
    newVNode = newChildren[newEnd];
  }
}
```
此操作后，状态如下图
![](Pasted%20image%2020220321231553.png)


